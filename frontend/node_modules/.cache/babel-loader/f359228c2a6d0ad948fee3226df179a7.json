{"ast":null,"code":"// config.js (c) 2010-2020 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-config\n// Dependencies\nvar deferConfig = require('../defer').deferConfig,\n    DeferredConfig = require('../defer').DeferredConfig,\n    RawConfig = require('../raw').RawConfig,\n    Parser = require('../parser'),\n    Utils = require('util'),\n    Path = require('path'),\n    FileSystem = require('fs'); // Static members\n\n\nvar DEFAULT_CLONE_DEPTH = 20,\n    NODE_CONFIG,\n    CONFIG_DIR,\n    RUNTIME_JSON_FILENAME,\n    NODE_ENV,\n    APP_INSTANCE,\n    HOST,\n    HOSTNAME,\n    ALLOW_CONFIG_MUTATIONS,\n    CONFIG_SKIP_GITCRYPT,\n    NODE_ENV_VAR_NAME,\n    NODE_CONFIG_PARSER,\n    env = {},\n    privateUtil = {},\n    deprecationWarnings = {},\n    configSources = [],\n    // Configuration sources - array of {name, original, parsed}\ncheckMutability = true,\n    // Check for mutability/immutability on first get\ngitCryptTestRegex = /^.GITCRYPT/; // regular expression to test for gitcrypt files.\n\n/**\n * <p>Application Configurations</p>\n *\n * <p>\n * The config module exports a singleton object representing all\n * configurations for this application deployment.\n * </p>\n *\n * <p>\n * Application configurations are stored in files within the config directory\n * of your application.  The default configuration file is loaded, followed\n * by files specific to the deployment type (development, testing, staging,\n * production, etc.).\n * </p>\n *\n * <p>\n * For example, with the following config/default.yaml file:\n * </p>\n *\n * <pre>\n *   ...\n *   customer:\n *     &nbsp;&nbsp;initialCredit: 500\n *     &nbsp;&nbsp;db:\n *       &nbsp;&nbsp;&nbsp;&nbsp;name: customer\n *       &nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n *   ...\n * </pre>\n *\n * <p>\n * The following code loads the customer section into the CONFIG variable:\n * <p>\n *\n * <pre>\n *   var CONFIG = require('config').customer;\n *   ...\n *   newCustomer.creditLimit = CONFIG.initialCredit;\n *   database.open(CONFIG.db.name, CONFIG.db.port);\n *   ...\n * </pre>\n *\n * @module config\n * @class Config\n */\n\n/**\n * <p>Get the configuration object.</p>\n *\n * <p>\n * The configuration object is a shared singleton object within the application,\n * attained by calling require('config').\n * </p>\n *\n * <p>\n * Usually you'll specify a CONFIG variable at the top of your .js file\n * for file/module scope. If you want the root of the object, you can do this:\n * </p>\n * <pre>\n * var CONFIG = require('config');\n * </pre>\n *\n * <p>\n * Sometimes you only care about a specific sub-object within the CONFIG\n * object.  In that case you could do this at the top of your file:\n * </p>\n * <pre>\n * var CONFIG = require('config').customer;\n * or\n * var CUSTOMER_CONFIG = require('config').customer;\n * </pre>\n *\n * <script type=\"text/javascript\">\n *   document.getElementById(\"showProtected\").style.display = \"block\";\n * </script>\n *\n * @method constructor\n * @return CONFIG {object} - The top level configuration object\n */\n\nvar Config = function () {\n  var t = this; // Bind all utility functions to this\n\n  for (var fnName in util) {\n    if (typeof util[fnName] === 'function') {\n      util[fnName] = util[fnName].bind(t);\n    }\n  } // Merge configurations into this\n\n\n  util.extendDeep(t, util.loadFileConfigs());\n  util.attachProtoDeep(t); // Perform strictness checks and possibly throw an exception.\n\n  util.runStrictnessChecks(t);\n};\n/**\n * Utilities are under the util namespace vs. at the top level\n */\n\n\nvar util = Config.prototype.util = {};\n/**\n * Underlying get mechanism\n *\n * @private\n * @method getImpl\n * @param object {object} - Object to get the property for\n * @param property {string|string[]} - The property name to get (as an array or '.' delimited string)\n * @return value {*} - Property value, including undefined if not defined.\n */\n\nvar getImpl = function (object, property) {\n  var t = this,\n      elems = Array.isArray(property) ? property : property.split('.'),\n      name = elems[0],\n      value = object[name];\n\n  if (elems.length <= 1) {\n    return value;\n  } // Note that typeof null === 'object'\n\n\n  if (value === null || typeof value !== 'object') {\n    return undefined;\n  }\n\n  return getImpl(value, elems.slice(1));\n};\n/**\n * <p>Get a configuration value</p>\n *\n * <p>\n * This will return the specified property value, throwing an exception if the\n * configuration isn't defined.  It is used to assure configurations are defined\n * before being used, and to prevent typos.\n * </p>\n *\n * @method get\n * @param property {string} - The configuration property to get. Can include '.' sub-properties.\n * @return value {*} - The property value\n */\n\n\nConfig.prototype.get = function (property) {\n  if (property === null || property === undefined) {\n    throw new Error(\"Calling config.get with null or undefined argument\");\n  } // Make configurations immutable after first get (unless disabled)\n\n\n  if (checkMutability) {\n    if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n      util.makeImmutable(config);\n    }\n\n    checkMutability = false;\n  }\n\n  var t = this,\n      value = getImpl(t, property); // Produce an exception if the property doesn't exist\n\n  if (value === undefined) {\n    throw new Error('Configuration property \"' + property + '\" is not defined');\n  } // Return the value\n\n\n  return value;\n};\n/**\n * Test that a configuration parameter exists\n *\n * <pre>\n *    var config = require('config');\n *    if (config.has('customer.dbName')) {\n *      console.log('Customer database name: ' + config.customer.dbName);\n *    }\n * </pre>\n *\n * @method has\n * @param property {string} - The configuration property to test. Can include '.' sub-properties.\n * @return isPresent {boolean} - True if the property is defined, false if not defined.\n */\n\n\nConfig.prototype.has = function (property) {\n  // While get() throws an exception for undefined input, has() is designed to test validity, so false is appropriate\n  if (property === null || property === undefined) {\n    return false;\n  }\n\n  var t = this;\n  return getImpl(t, property) !== undefined;\n};\n/**\n * <p>\n * Set default configurations for a node.js module.\n * </p>\n *\n * <p>\n * This allows module developers to attach their configurations onto the\n * default configuration object so they can be configured by the consumers\n * of the module.\n * </p>\n *\n * <p>Using the function within your module:</p>\n * <pre>\n *   var CONFIG = require(\"config\");\n *   CONFIG.util.setModuleDefaults(\"MyModule\", {\n *   &nbsp;&nbsp;templateName: \"t-50\",\n *   &nbsp;&nbsp;colorScheme: \"green\"\n *   });\n * <br>\n *   // Template name may be overridden by application config files\n *   console.log(\"Template: \" + CONFIG.MyModule.templateName);\n * </pre>\n *\n * <p>\n * The above example results in a \"MyModule\" element of the configuration\n * object, containing an object with the specified default values.\n * </p>\n *\n * @method setModuleDefaults\n * @param moduleName {string} - Name of your module.\n * @param defaultProperties {object} - The default module configuration.\n * @return moduleConfig {object} - The module level configuration object.\n */\n\n\nutil.setModuleDefaults = function (moduleName, defaultProperties) {\n  // Copy the properties into a new object\n  var t = this,\n      moduleConfig = util.cloneDeep(defaultProperties); // Set module defaults into the first sources element\n\n  if (configSources.length === 0 || configSources[0].name !== 'Module Defaults') {\n    configSources.splice(0, 0, {\n      name: 'Module Defaults',\n      parsed: {}\n    });\n  }\n\n  util.setPath(configSources[0].parsed, moduleName.split('.'), {});\n  util.extendDeep(getImpl(configSources[0].parsed, moduleName), defaultProperties); // Create a top level config for this module if it doesn't exist\n\n  util.setPath(t, moduleName.split('.'), getImpl(t, moduleName) || {}); // Extend local configurations into the module config\n\n  util.extendDeep(moduleConfig, getImpl(t, moduleName)); // Merge the extended configs without replacing the original\n\n  util.extendDeep(getImpl(t, moduleName), moduleConfig); // reset the mutability check for \"config.get\" method.\n  // we are not making t[moduleName] immutable immediately,\n  // since there might be more modifications before the first config.get\n\n  if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n    checkMutability = true;\n  } // Attach handlers & watchers onto the module config object\n\n\n  return util.attachProtoDeep(getImpl(t, moduleName));\n};\n/**\n * <p>Make a configuration property hidden so it doesn't appear when enumerating\n * elements of the object.</p>\n *\n * <p>\n * The property still exists and can be read from and written to, but it won't\n * show up in for ... in loops, Object.keys(), or JSON.stringify() type methods.\n * </p>\n *\n * <p>\n * If the property already exists, it will be made hidden.  Otherwise it will\n * be created as a hidden property with the specified value.\n * </p>\n *\n * <p><i>\n * This method was built for hiding configuration values, but it can be applied\n * to <u>any</u> javascript object.\n * </i></p>\n *\n * <p>Example:</p>\n * <pre>\n *   var CONFIG = require('config');\n *   ...\n *\n *   // Hide the Amazon S3 credentials\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'access_id');\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'secret_key');\n * </pre>\n *\n * @method makeHidden\n * @param object {object} - The object to make a hidden property into.\n * @param property {string} - The name of the property to make hidden.\n * @param value {*} - (optional) Set the property value to this (otherwise leave alone)\n * @return object {object} - The original object is returned - for chaining.\n */\n\n\nutil.makeHidden = function (object, property, value) {\n  // If the new value isn't specified, just mark the property as hidden\n  if (typeof value === 'undefined') {\n    Object.defineProperty(object, property, {\n      enumerable: false\n    });\n  } // Otherwise set the value and mark it as hidden\n  else {\n    Object.defineProperty(object, property, {\n      value: value,\n      enumerable: false\n    });\n  }\n\n  return object;\n};\n/**\n * <p>Make a javascript object property immutable (assuring it cannot be changed\n * from the current value).</p>\n * <p>\n * If the specified property is an object, all attributes of that object are\n * made immutable, including properties of contained objects, recursively.\n * If a property name isn't supplied, all properties of the object are made\n * immutable.\n * </p>\n * <p>\n *\n * </p>\n * <p>\n * New properties can be added to the object and those properties will not be\n * immutable unless this method is called on those new properties.\n * </p>\n * <p>\n * This operation cannot be undone.\n * </p>\n *\n * <p>Example:</p>\n * <pre>\n *   var config = require('config');\n *   var myObject = {hello:'world'};\n *   config.util.makeImmutable(myObject);\n * </pre>\n *\n * @method makeImmutable\n * @param object {object} - The object to specify immutable properties for\n * @param [property] {string | [string]} - The name of the property (or array of names) to make immutable.\n *        If not provided, all owned properties of the object are made immutable.\n * @param [value] {* | [*]} - Property value (or array of values) to set\n *        the property to before making immutable. Only used when setting a single\n *        property. Retained for backward compatibility.\n * @return object {object} - The original object is returned - for chaining.\n */\n\n\nutil.makeImmutable = function (object, property, value) {\n  if (Buffer.isBuffer(object)) {\n    return object;\n  }\n\n  var properties = null; // Backwards compatibility mode where property/value can be specified\n\n  if (typeof property === 'string') {\n    return Object.defineProperty(object, property, {\n      value: typeof value === 'undefined' ? object[property] : value,\n      writable: false,\n      configurable: false\n    });\n  } // Get the list of properties to work with\n\n\n  if (Array.isArray(property)) {\n    properties = property;\n  } else {\n    properties = Object.keys(object);\n  } // Process each property\n\n\n  for (var i = 0; i < properties.length; i++) {\n    var propertyName = properties[i],\n        value = object[propertyName];\n\n    if (value instanceof RawConfig) {\n      Object.defineProperty(object, propertyName, {\n        value: value.resolve(),\n        writable: false,\n        configurable: false\n      });\n    } else if (Array.isArray(value)) {\n      // Ensure object items of this array are also immutable.\n      value.forEach((item, index) => {\n        if (util.isObject(item) || Array.isArray(item)) util.makeImmutable(item);\n      });\n      Object.defineProperty(object, propertyName, {\n        value: Object.freeze(value)\n      });\n    } else {\n      Object.defineProperty(object, propertyName, {\n        value: value,\n        writable: false,\n        configurable: false\n      }); // Ensure new properties can not be added.\n\n      Object.preventExtensions(object); // Call recursively if an object.\n\n      if (util.isObject(value)) {\n        util.makeImmutable(value);\n      }\n    }\n  }\n\n  return object;\n};\n/**\n * Return the sources for the configurations\n *\n * <p>\n * All sources for configurations are stored in an array of objects containing\n * the source name (usually the filename), the original source (as a string),\n * and the parsed source as an object.\n * </p>\n *\n * @method getConfigSources\n * @return configSources {Array[Object]} - An array of objects containing\n *    name, original, and parsed elements\n */\n\n\nutil.getConfigSources = function () {\n  var t = this;\n  return configSources.slice(0);\n};\n/**\n * Looks into an options object for a specific attribute\n *\n * <p>\n * This method looks into the options object, and if an attribute is defined, returns it,\n * and if not, returns the default value\n * </p>\n *\n * @method getOption\n * @param options {Object | undefined} the options object\n * @param optionName {string} the attribute name to look for\n * @param defaultValue { any } the default in case the options object is empty, or the attribute does not exist.\n * @return options[optionName] if defined, defaultValue if not.\n */\n\n\nutil.getOption = function (options, optionName, defaultValue) {\n  if (options !== undefined && options[optionName] !== undefined) {\n    return options[optionName];\n  } else {\n    return defaultValue;\n  }\n};\n/**\n * Load the individual file configurations.\n *\n * <p>\n * This method builds a map of filename to the configuration object defined\n * by the file.  The search order is:\n * </p>\n *\n * <pre>\n *   default.EXT\n *   (deployment).EXT\n *   (hostname).EXT\n *   (hostname)-(deployment).EXT\n *   local.EXT\n *   local-(deployment).EXT\n *   runtime.json\n * </pre>\n *\n * <p>\n * EXT can be yml, yaml, coffee, iced, json, cson or js signifying the file type.\n * yaml (and yml) is in YAML format, coffee is a coffee-script, iced is iced-coffee-script,\n * json is in JSON format, cson is in CSON format, properties is in .properties format\n * (http://en.wikipedia.org/wiki/.properties), and js is a javascript executable file that is\n * require()'d with module.exports being the config object.\n * </p>\n *\n * <p>\n * hostname is the $HOST environment variable (or --HOST command line parameter)\n * if set, otherwise the $HOSTNAME environment variable (or --HOSTNAME command\n * line parameter) if set, otherwise the hostname found from\n * require('os').hostname().\n * </p>\n *\n * <p>\n * Once a hostname is found, everything from the first period ('.') onwards\n * is removed. For example, abc.example.com becomes abc\n * </p>\n *\n * <p>\n * (deployment) is the deployment type, found in the $NODE_ENV environment\n * variable (which can be overridden by using $NODE_CONFIG_ENV\n * environment variable). Defaults to 'development'.\n * </p>\n *\n * <p>\n * The runtime.json file contains configuration changes made at runtime either\n * manually, or by the application setting a configuration value.\n * </p>\n *\n * <p>\n * If the $NODE_APP_INSTANCE environment variable (or --NODE_APP_INSTANCE\n * command line parameter) is set, then files with this appendage will be loaded.\n * See the Multiple Application Instances section of the main documentation page\n * for more information.\n * </p>\n *\n * @protected\n * @method loadFileConfigs\n * @param configDir { string | null } the path to the directory containing the configurations to load\n * @param options { object | undefined } parsing options. Current supported option: skipConfigSources: true|false\n * @return config {Object} The configuration object\n */\n\n\nutil.loadFileConfigs = function (configDir, options) {\n  // Initialize\n  var t = this,\n      config = {}; // Specify variables that can be used to define the environment\n\n  var node_env_var_names = ['NODE_CONFIG_ENV', 'NODE_ENV']; // Loop through the variables to try and set environment\n\n  for (const node_env_var_name of node_env_var_names) {\n    NODE_ENV = util.initParam(node_env_var_name);\n\n    if (!!NODE_ENV) {\n      NODE_ENV_VAR_NAME = node_env_var_name;\n      break;\n    }\n  } // If we haven't successfully set the environment using the variables, we'll default it\n\n\n  if (!NODE_ENV) {\n    NODE_ENV = 'development';\n  }\n\n  node_env_var_names.forEach(node_env_var_name => {\n    env[node_env_var_name] = NODE_ENV;\n  }); // Split files name, for loading multiple files.\n\n  NODE_ENV = NODE_ENV.split(',');\n  CONFIG_DIR = configDir || util.initParam('NODE_CONFIG_DIR', Path.join(process.cwd(), 'config'));\n\n  if (CONFIG_DIR.indexOf('.') === 0) {\n    CONFIG_DIR = Path.join(process.cwd(), CONFIG_DIR);\n  }\n\n  APP_INSTANCE = util.initParam('NODE_APP_INSTANCE');\n  HOST = util.initParam('HOST');\n  HOSTNAME = util.initParam('HOSTNAME');\n  CONFIG_SKIP_GITCRYPT = util.initParam('CONFIG_SKIP_GITCRYPT'); // This is for backward compatibility\n\n  RUNTIME_JSON_FILENAME = util.initParam('NODE_CONFIG_RUNTIME_JSON', Path.join(CONFIG_DIR, 'runtime.json'));\n  NODE_CONFIG_PARSER = util.initParam('NODE_CONFIG_PARSER');\n\n  if (NODE_CONFIG_PARSER) {\n    try {\n      var parserModule = Path.isAbsolute(NODE_CONFIG_PARSER) ? NODE_CONFIG_PARSER : Path.join(CONFIG_DIR, NODE_CONFIG_PARSER);\n      Parser = require(parserModule);\n    } catch (e) {\n      console.warn('Failed to load config parser from ' + NODE_CONFIG_PARSER);\n      console.log(e);\n    }\n  } // Determine the host name from the OS module, $HOST, or $HOSTNAME\n  // Remove any . appendages, and default to null if not set\n\n\n  try {\n    var hostName = HOST || HOSTNAME;\n\n    if (!hostName) {\n      var OS = require('os');\n\n      hostName = OS.hostname();\n    }\n  } catch (e) {\n    hostName = '';\n  } // Store the hostname that won.\n\n\n  env.HOSTNAME = hostName; // Read each file in turn\n\n  var baseNames = ['default'].concat(NODE_ENV); // #236: Also add full hostname when they are different.\n\n  if (hostName) {\n    var firstDomain = hostName.split('.')[0];\n    NODE_ENV.forEach(function (env) {\n      // Backward compatibility\n      baseNames.push(firstDomain, firstDomain + '-' + env); // Add full hostname when it is not the same\n\n      if (hostName !== firstDomain) {\n        baseNames.push(hostName, hostName + '-' + env);\n      }\n    });\n  }\n\n  NODE_ENV.forEach(function (env) {\n    baseNames.push('local', 'local-' + env);\n  });\n  var allowedFiles = {};\n  var resolutionIndex = 1;\n  var extNames = Parser.getFilesOrder();\n  baseNames.forEach(function (baseName) {\n    extNames.forEach(function (extName) {\n      allowedFiles[baseName + '.' + extName] = resolutionIndex++;\n\n      if (APP_INSTANCE) {\n        allowedFiles[baseName + '-' + APP_INSTANCE + '.' + extName] = resolutionIndex++;\n      }\n    });\n  });\n  var locatedFiles = util.locateMatchingFiles(CONFIG_DIR, allowedFiles);\n  locatedFiles.forEach(function (fullFilename) {\n    var configObj = util.parseFile(fullFilename, options);\n\n    if (configObj) {\n      util.extendDeep(config, configObj);\n    }\n  }); // Override configurations from the $NODE_CONFIG environment variable\n  // NODE_CONFIG only applies to the base config\n\n  if (!configDir) {\n    var envConfig = {};\n\n    if (process.env.NODE_CONFIG) {\n      try {\n        envConfig = JSON.parse(process.env.NODE_CONFIG);\n      } catch (e) {\n        console.error('The $NODE_CONFIG environment variable is malformed JSON');\n      }\n\n      util.extendDeep(config, envConfig);\n      var skipConfigSources = util.getOption(options, 'skipConfigSources', false);\n\n      if (!skipConfigSources) {\n        configSources.push({\n          name: \"$NODE_CONFIG\",\n          parsed: envConfig\n        });\n      }\n    } // Override configurations from the --NODE_CONFIG command line\n\n\n    var cmdLineConfig = util.getCmdLineArg('NODE_CONFIG');\n\n    if (cmdLineConfig) {\n      try {\n        cmdLineConfig = JSON.parse(cmdLineConfig);\n      } catch (e) {\n        console.error('The --NODE_CONFIG={json} command line argument is malformed JSON');\n      }\n\n      util.extendDeep(config, cmdLineConfig);\n      var skipConfigSources = util.getOption(options, 'skipConfigSources', false);\n\n      if (!skipConfigSources) {\n        configSources.push({\n          name: \"--NODE_CONFIG argument\",\n          parsed: cmdLineConfig\n        });\n      }\n    } // Place the mixed NODE_CONFIG into the environment\n\n\n    env['NODE_CONFIG'] = JSON.stringify(util.extendDeep(envConfig, cmdLineConfig, {}));\n  } // Override with environment variables if there is a custom-environment-variables.EXT mapping file\n\n\n  var customEnvVars = util.getCustomEnvVars(CONFIG_DIR, extNames);\n  util.extendDeep(config, customEnvVars); // Extend the original config with the contents of runtime.json (backwards compatibility)\n\n  var runtimeJson = util.parseFile(RUNTIME_JSON_FILENAME) || {};\n  util.extendDeep(config, runtimeJson);\n  util.resolveDeferredConfigs(config); // Return the configuration object\n\n  return config;\n};\n/**\n * Return a list of fullFilenames who exists in allowedFiles\n * Ordered according to allowedFiles argument specifications\n *\n * @protected\n * @method locateMatchingFiles\n * @param configDirs {string}   the config dir, or multiple dirs separated by a column (:)\n * @param allowedFiles {object} an object. keys and supported filenames\n *                              and values are the position in the resolution order\n * @returns {string[]}          fullFilenames - path + filename\n */\n\n\nutil.locateMatchingFiles = function (configDirs, allowedFiles) {\n  return configDirs.split(Path.delimiter).reduce(function (files, configDir) {\n    if (configDir) {\n      try {\n        FileSystem.readdirSync(configDir).forEach(function (file) {\n          if (allowedFiles[file]) {\n            files.push([allowedFiles[file], Path.join(configDir, file)]);\n          }\n        });\n      } catch (e) {}\n\n      return files;\n    }\n  }, []).sort(function (a, b) {\n    return a[0] - b[0];\n  }).map(function (file) {\n    return file[1];\n  });\n}; // Using basic recursion pattern, find all the deferred values and resolve them.\n\n\nutil.resolveDeferredConfigs = function (config) {\n  var deferred = [];\n\n  function _iterate(prop) {\n    // We put the properties we are going to look it in an array to keep the order predictable\n    var propsToSort = []; // First step is to put the properties of interest in an array\n\n    for (var property in prop) {\n      if (Object.hasOwnProperty.call(prop, property) && prop[property] != null) {\n        propsToSort.push(property);\n      }\n    } // Second step is to iterate of the elements in a predictable (sorted) order\n\n\n    propsToSort.sort().forEach(function (property) {\n      if (prop[property].constructor === Object) {\n        _iterate(prop[property]);\n      } else if (prop[property].constructor === Array) {\n        for (var i = 0; i < prop[property].length; i++) {\n          if (prop[property][i] instanceof DeferredConfig) {\n            deferred.push(prop[property][i].prepare(config, prop[property], i));\n          } else {\n            _iterate(prop[property][i]);\n          }\n        }\n      } else {\n        if (prop[property] instanceof DeferredConfig) {\n          deferred.push(prop[property].prepare(config, prop, property));\n        } // else: Nothing to do. Keep the property how it is.\n\n      }\n    });\n  }\n\n  _iterate(config);\n\n  deferred.forEach(function (defer) {\n    defer.resolve();\n  });\n};\n/**\n * Parse and return the specified configuration file.\n *\n * If the file exists in the application config directory, it will\n * parse and return it as a JavaScript object.\n *\n * The file extension determines the parser to use.\n *\n * .js = File to run that has a module.exports containing the config object\n * .coffee = File to run that has a module.exports with coffee-script containing the config object\n * .iced = File to run that has a module.exports with iced-coffee-script containing the config object\n * All other supported file types (yaml, toml, json, cson, hjson, json5, properties, xml)\n * are parsed with util.parseString.\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseFile\n * @param fullFilename {string} The full file path and name\n * @param options { object | undefined } parsing options. Current supported option: skipConfigSources: true|false\n * @return configObject {object|null} The configuration object parsed from the file\n */\n\n\nutil.parseFile = function (fullFilename, options) {\n  var t = this,\n      // Initialize\n  configObject = null,\n      fileContent = null,\n      stat = null; // Note that all methods here are the Sync versions.  This is appropriate during\n  // module loading (which is a synchronous operation), but not thereafter.\n\n  try {\n    // Try loading the file.\n    fileContent = FileSystem.readFileSync(fullFilename, 'utf-8');\n    fileContent = fileContent.replace(/^\\uFEFF/, '');\n  } catch (e2) {\n    if (e2.code !== 'ENOENT') {\n      throw new Error('Config file ' + fullFilename + ' cannot be read. Error code is: ' + e2.code + '. Error message is: ' + e2.message);\n    }\n\n    return null; // file doesn't exists\n  } // Parse the file based on extension\n\n\n  try {\n    // skip if it's a gitcrypt file and CONFIG_SKIP_GITCRYPT is true\n    if (CONFIG_SKIP_GITCRYPT) {\n      if (gitCryptTestRegex.test(fileContent)) {\n        console.error('WARNING: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is set. skipping.');\n        return null;\n      }\n    }\n\n    configObject = Parser.parse(fullFilename, fileContent);\n  } catch (e3) {\n    if (gitCryptTestRegex.test(fileContent)) {\n      console.error('ERROR: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is not set.');\n    }\n\n    throw new Error(\"Cannot parse config file: '\" + fullFilename + \"': \" + e3);\n  } // Keep track of this configuration sources, including empty ones, unless the skipConfigSources flag is set to true in the options\n\n\n  var skipConfigSources = util.getOption(options, 'skipConfigSources', false);\n\n  if (typeof configObject === 'object' && !skipConfigSources) {\n    configSources.push({\n      name: fullFilename,\n      original: fileContent,\n      parsed: configObject\n    });\n  }\n\n  return configObject;\n};\n/**\n * Parse and return the specified string with the specified format.\n *\n * The format determines the parser to use.\n *\n * json = File is parsed using JSON.parse()\n * yaml (or yml) = Parsed with a YAML parser\n * toml = Parsed with a TOML parser\n * cson = Parsed with a CSON parser\n * hjson = Parsed with a HJSON parser\n * json5 = Parsed with a JSON5 parser\n * properties = Parsed with the 'properties' node package\n * xml = Parsed with a XML parser\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseString\n * @param content {string} The full content\n * @param format {string} The format to be parsed\n * @return {configObject} The configuration object parsed from the string\n */\n\n\nutil.parseString = function (content, format) {\n  var parser = Parser.getParser(format);\n\n  if (typeof parser === 'function') {\n    return parser(null, content);\n  }\n};\n/**\n * Attach the Config class prototype to all config objects recursively.\n *\n * <p>\n * This allows you to do anything with CONFIG sub-objects as you can do with\n * the top-level CONFIG object.  It's so you can do this:\n * </p>\n *\n * <pre>\n *   var CUST_CONFIG = require('config').Customer;\n *   CUST_CONFIG.get(...)\n * </pre>\n *\n * @protected\n * @method attachProtoDeep\n * @param toObject\n * @param depth\n * @return toObject\n */\n\n\nutil.attachProtoDeep = function (toObject, depth) {\n  if (toObject instanceof RawConfig) {\n    return toObject;\n  } // Recursion detection\n\n\n  var t = this;\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n\n  if (depth < 0) {\n    return toObject;\n  } // Adding Config.prototype methods directly to toObject as hidden properties\n  // because adding to toObject.__proto__ exposes the function in toObject\n\n\n  for (var fnName in Config.prototype) {\n    if (!toObject[fnName]) {\n      util.makeHidden(toObject, fnName, Config.prototype[fnName]);\n    }\n  } // Add prototypes to sub-objects\n\n\n  for (var prop in toObject) {\n    if (util.isObject(toObject[prop])) {\n      util.attachProtoDeep(toObject[prop], depth - 1);\n    }\n  } // Return the original object\n\n\n  return toObject;\n};\n/**\n * Return a deep copy of the specified object.\n *\n * This returns a new object with all elements copied from the specified\n * object.  Deep copies are made of objects and arrays so you can do anything\n * with the returned object without affecting the input object.\n *\n * @protected\n * @method cloneDeep\n * @param parent {object} The original object to copy from\n * @param [depth=20] {Integer} Maximum depth (default 20)\n * @return {object} A new object with the elements copied from the copyFrom object\n *\n * This method is copied from https://github.com/pvorb/node-clone/blob/17eea36140d61d97a9954c53417d0e04a00525d9/clone.js\n *\n * Copyright © 2011-2014 Paul Vorbach and contributors.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions: The above copyright notice and this permission\n * notice shall be included in all copies or substantial portions of the Software.\n */\n\n\nutil.cloneDeep = function cloneDeep(parent, depth, circular, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n  var useBuffer = typeof Buffer != 'undefined';\n  if (typeof circular === 'undefined') circular = true;\n  if (typeof depth === 'undefined') depth = 20; // recurse this function so we don't reset allParents and allChildren\n\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null) return null;\n    if (depth === 0) return parent;\n    var child;\n\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (Utils.isArray(parent)) {\n      child = [];\n    } else if (Utils.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (Utils.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = Buffer.alloc(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype === 'undefined') child = Object.create(Object.getPrototypeOf(parent));else child = Object.create(prototype);\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var propDescriptor = Object.getOwnPropertyDescriptor(parent, i);\n      var hasGetter = propDescriptor !== undefined && propDescriptor.get !== undefined;\n\n      if (hasGetter) {\n        Object.defineProperty(child, i, propDescriptor);\n      } else if (util.isPromise(parent[i])) {\n        child[i] = parent[i];\n      } else {\n        child[i] = _clone(parent[i], depth - 1);\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n};\n/**\n * Set objects given a path as a string list\n *\n * @protected\n * @method setPath\n * @param object {object} - Object to set the property on\n * @param path {array[string]} - Array path to the property\n * @param value {*} - value to set, ignoring null\n */\n\n\nutil.setPath = function (object, path, value) {\n  var nextKey = null;\n\n  if (value === null || path.length === 0) {\n    return;\n  } else if (path.length === 1) {\n    // no more keys to make, so set the value\n    object[path.shift()] = value;\n  } else {\n    nextKey = path.shift();\n\n    if (!Object.hasOwnProperty.call(object, nextKey)) {\n      object[nextKey] = {};\n    }\n\n    util.setPath(object[nextKey], path, value);\n  }\n};\n/**\n * Create a new object patterned after substitutionMap, where:\n * 1. Terminal string values in substitutionMap are used as keys\n * 2. To look up values in a key-value store, variables\n * 3. And parent keys are created as necessary to retain the structure of substitutionMap.\n *\n * @protected\n * @method substituteDeep\n * @param substitutionMap {object} - an object whose terminal (non-subobject) values are strings\n * @param variables {object[string:value]} - usually process.env, a flat object used to transform\n *      terminal values in a copy of substitutionMap.\n * @returns {object} - deep copy of substitutionMap with only those paths whose terminal values\n *      corresponded to a key in `variables`\n */\n\n\nutil.substituteDeep = function (substitutionMap, variables) {\n  var result = {};\n\n  function _substituteVars(map, vars, pathTo) {\n    for (var prop in map) {\n      var value = map[prop];\n\n      if (typeof value === 'string') {\n        // We found a leaf variable name\n        if (vars[value] !== undefined && vars[value] !== '') {\n          // if the vars provide a value set the value in the result map\n          util.setPath(result, pathTo.concat(prop), vars[value]);\n        }\n      } else if (util.isObject(value)) {\n        // work on the subtree, giving it a clone of the pathTo\n        if ('__name' in value && '__format' in value && vars[value.__name] !== undefined && vars[value.__name] !== '') {\n          try {\n            var parsedValue = util.parseString(vars[value.__name], value.__format);\n          } catch (err) {\n            err.message = '__format parser error in ' + value.__name + ': ' + err.message;\n            throw err;\n          }\n\n          util.setPath(result, pathTo.concat(prop), parsedValue);\n        } else {\n          _substituteVars(value, vars, pathTo.concat(prop));\n        }\n      } else {\n        msg = \"Illegal key type for substitution map at \" + pathTo.join('.') + ': ' + typeof value;\n        throw Error(msg);\n      }\n    }\n  }\n\n  _substituteVars(substitutionMap, variables, []);\n\n  return result;\n};\n/* Map environment variables into the configuration if a mapping file,\n * `custom-environment-variables.EXT` exists.\n *\n * @protected\n * @method getCustomEnvVars\n * @param CONFIG_DIR {string} - the passed configuration directory\n * @param extNames {Array[string]} - acceptable configuration file extension names.\n * @returns {object} - mapped environment variables or {} if there are none\n */\n\n\nutil.getCustomEnvVars = function (CONFIG_DIR, extNames) {\n  var result = {};\n  var resolutionIndex = 1;\n  var allowedFiles = {};\n  extNames.forEach(function (extName) {\n    allowedFiles['custom-environment-variables' + '.' + extName] = resolutionIndex++;\n  });\n  var locatedFiles = util.locateMatchingFiles(CONFIG_DIR, allowedFiles);\n  locatedFiles.forEach(function (fullFilename) {\n    var configObj = util.parseFile(fullFilename);\n\n    if (configObj) {\n      var environmentSubstitutions = util.substituteDeep(configObj, process.env);\n      util.extendDeep(result, environmentSubstitutions);\n    }\n  });\n  return result;\n};\n/**\n * Return true if two objects have equal contents.\n *\n * @protected\n * @method equalsDeep\n * @param object1 {object} The object to compare from\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {boolean} True if both objects have equivalent contents\n */\n\n\nutil.equalsDeep = function (object1, object2, depth) {\n  // Recursion detection\n  var t = this;\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n\n  if (depth < 0) {\n    return {};\n  } // Fast comparisons\n\n\n  if (!object1 || !object2) {\n    return false;\n  }\n\n  if (object1 === object2) {\n    return true;\n  }\n\n  if (typeof object1 != 'object' || typeof object2 != 'object') {\n    return false;\n  } // They must have the same keys.  If their length isn't the same\n  // then they're not equal.  If the keys aren't the same, the value\n  // comparisons will fail.\n\n\n  if (Object.keys(object1).length != Object.keys(object2).length) {\n    return false;\n  } // Compare the values\n\n\n  for (var prop in object1) {\n    // Call recursively if an object or array\n    if (object1[prop] && typeof object1[prop] === 'object') {\n      if (!util.equalsDeep(object1[prop], object2[prop], depth - 1)) {\n        return false;\n      }\n    } else {\n      if (object1[prop] !== object2[prop]) {\n        return false;\n      }\n    }\n  } // Test passed.\n\n\n  return true;\n};\n/**\n * Returns an object containing all elements that differ between two objects.\n * <p>\n * This method was designed to be used to create the runtime.json file\n * contents, but can be used to get the diffs between any two Javascript objects.\n * </p>\n * <p>\n * It works best when object2 originated by deep copying object1, then\n * changes were made to object2, and you want an object that would give you\n * the changes made to object1 which resulted in object2.\n * </p>\n *\n * @protected\n * @method diffDeep\n * @param object1 {object} The base object to compare to\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} A differential object, which if extended onto object1 would\n *                  result in object2.\n */\n\n\nutil.diffDeep = function (object1, object2, depth) {\n  // Recursion detection\n  var t = this,\n      diff = {};\n  depth = depth === null ? DEFAULT_CLONE_DEPTH : depth;\n\n  if (depth < 0) {\n    return {};\n  } // Process each element from object2, adding any element that's different\n  // from object 1.\n\n\n  for (var parm in object2) {\n    var value1 = object1[parm];\n    var value2 = object2[parm];\n\n    if (value1 && value2 && util.isObject(value2)) {\n      if (!util.equalsDeep(value1, value2)) {\n        diff[parm] = util.diffDeep(value1, value2, depth - 1);\n      }\n    } else if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (!util.equalsDeep(value1, value2)) {\n        diff[parm] = value2;\n      }\n    } else if (value1 !== value2) {\n      diff[parm] = value2;\n    }\n  } // Return the diff object\n\n\n  return diff;\n};\n/**\n * Extend an object, and any object it contains.\n *\n * This does not replace deep objects, but dives into them\n * replacing individual elements instead.\n *\n * @protected\n * @method extendDeep\n * @param mergeInto {object} The object to merge into\n * @param mergeFrom... {object...} - Any number of objects to merge from\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} The altered mergeInto object is returned\n */\n\n\nutil.extendDeep = function (mergeInto) {\n  // Initialize\n  var t = this;\n  var vargs = Array.prototype.slice.call(arguments, 1);\n  var depth = vargs.pop();\n\n  if (typeof depth != 'number') {\n    vargs.push(depth);\n    depth = DEFAULT_CLONE_DEPTH;\n  } // Recursion detection\n\n\n  if (depth < 0) {\n    return mergeInto;\n  } // Cycle through each object to extend\n\n\n  vargs.forEach(function (mergeFrom) {\n    // Cycle through each element of the object to merge from\n    for (var prop in mergeFrom) {\n      // save original value in deferred elements\n      var fromIsDeferredFunc = mergeFrom[prop] instanceof DeferredConfig;\n      var isDeferredFunc = mergeInto[prop] instanceof DeferredConfig;\n\n      if (fromIsDeferredFunc && Object.hasOwnProperty.call(mergeInto, prop)) {\n        mergeFrom[prop]._original = isDeferredFunc ? mergeInto[prop]._original : mergeInto[prop];\n      } // Extend recursively if both elements are objects and target is not really a deferred function\n\n\n      if (mergeFrom[prop] instanceof Date) {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n\n      if (mergeFrom[prop] instanceof RegExp) {\n        mergeInto[prop] = mergeFrom[prop];\n      } else if (util.isObject(mergeInto[prop]) && util.isObject(mergeFrom[prop]) && !isDeferredFunc) {\n        util.extendDeep(mergeInto[prop], mergeFrom[prop], depth - 1);\n      } else if (util.isPromise(mergeFrom[prop])) {\n        mergeInto[prop] = mergeFrom[prop];\n      } // Copy recursively if the mergeFrom element is an object (or array or fn)\n      else if (mergeFrom[prop] && typeof mergeFrom[prop] === 'object') {\n        mergeInto[prop] = util.cloneDeep(mergeFrom[prop], depth - 1);\n      } // Copy property descriptor otherwise, preserving accessors\n      else if (Object.getOwnPropertyDescriptor(Object(mergeFrom), prop)) {\n        Object.defineProperty(mergeInto, prop, Object.getOwnPropertyDescriptor(Object(mergeFrom), prop));\n      } else {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n    }\n  }); // Chain\n\n  return mergeInto;\n};\n/**\n * Is the specified argument a regular javascript object?\n *\n * The argument is an object if it's a JS object, but not an array.\n *\n * @protected\n * @method isObject\n * @param obj {*} An argument of any type.\n * @return {boolean} TRUE if the arg is an object, FALSE if not\n */\n\n\nutil.isObject = function (obj) {\n  return obj !== null && typeof obj === 'object' && !Array.isArray(obj);\n};\n/**\n * Is the specified argument a javascript promise?\n *\n * @protected\n * @method isPromise\n * @param obj {*} An argument of any type.\n * @returns {boolean}\n */\n\n\nutil.isPromise = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Promise]';\n};\n/**\n * <p>Initialize a parameter from the command line or process environment</p>\n *\n * <p>\n * This method looks for the parameter from the command line in the format\n * --PARAMETER=VALUE, then from the process environment, then from the\n * default specified as an argument.\n * </p>\n *\n * @method initParam\n * @param paramName {String} Name of the parameter\n * @param [defaultValue] {Any} Default value of the parameter\n * @return {Any} The found value, or default value\n */\n\n\nutil.initParam = function (paramName, defaultValue) {\n  var t = this; // Record and return the value\n\n  var value = util.getCmdLineArg(paramName) || process.env[paramName] || defaultValue;\n  env[paramName] = value;\n  return value;\n};\n/**\n * <p>Get Command Line Arguments</p>\n *\n * <p>\n * This method allows you to retrieve the value of the specified command line argument.\n * </p>\n *\n * <p>\n * The argument is case sensitive, and must be of the form '--ARG_NAME=value'\n * </p>\n *\n * @method getCmdLineArg\n * @param searchFor {String} The argument name to search for\n * @return {*} false if the argument was not found, the argument value if found\n */\n\n\nutil.getCmdLineArg = function (searchFor) {\n  var cmdLineArgs = process.argv.slice(2, process.argv.length),\n      argName = '--' + searchFor + '=';\n\n  for (var argvIt = 0; argvIt < cmdLineArgs.length; argvIt++) {\n    if (cmdLineArgs[argvIt].indexOf(argName) === 0) {\n      return cmdLineArgs[argvIt].substr(argName.length);\n    }\n  }\n\n  return false;\n};\n/**\n * <p>Get a Config Environment Variable Value</p>\n *\n * <p>\n * This method returns the value of the specified config environment variable,\n * including any defaults or overrides.\n * </p>\n *\n * @method getEnv\n * @param varName {String} The environment variable name\n * @return {String} The value of the environment variable\n */\n\n\nutil.getEnv = function (varName) {\n  return env[varName];\n};\n/**\n * Returns a string of flags for regular expression `re`.\n *\n * @param {RegExp} re Regular expression\n * @returns {string} Flags\n */\n\n\nutil.getRegExpFlags = function (re) {\n  var flags = '';\n  re.global && (flags += 'g');\n  re.ignoreCase && (flags += 'i');\n  re.multiline && (flags += 'm');\n  return flags;\n};\n/**\n * Returns a new deep copy of the current config object, or any part of the config if provided.\n *\n * @param {Object} config The part of the config to copy and serialize. Omit this argument to return the entire config.\n * @returns {Object} The cloned config or part of the config\n */\n\n\nutil.toObject = function (config) {\n  return JSON.parse(JSON.stringify(config || this));\n}; // Run strictness checks on NODE_ENV and NODE_APP_INSTANCE and throw an error if there's a problem.\n\n\nutil.runStrictnessChecks = function (config) {\n  var sources = config.util.getConfigSources();\n  var sourceFilenames = sources.map(function (src) {\n    return Path.basename(src.name);\n  });\n  NODE_ENV.forEach(function (env) {\n    // Throw an exception if there's no explicit config file for NODE_ENV\n    var anyFilesMatchEnv = sourceFilenames.some(function (filename) {\n      return filename.match(env);\n    }); // development is special-cased because it's the default value\n\n    if (env && env !== 'development' && !anyFilesMatchEnv) {\n      _warnOrThrow(NODE_ENV_VAR_NAME + \" value of '\" + env + \"' did not match any deployment config file names.\");\n    } // Throw if NODE_ENV matches' default' or 'local'\n\n\n    if (env === 'default' || env === 'local') {\n      _warnOrThrow(NODE_ENV_VAR_NAME + \" value of '\" + env + \"' is ambiguous.\");\n    }\n  }); // Throw an exception if there's no explicit config file for NODE_APP_INSTANCE\n\n  var anyFilesMatchInstance = sourceFilenames.some(function (filename) {\n    return filename.match(APP_INSTANCE);\n  });\n\n  if (APP_INSTANCE && !anyFilesMatchInstance) {\n    _warnOrThrow(\"NODE_APP_INSTANCE value of '\" + APP_INSTANCE + \"' did not match any instance config file names.\");\n  }\n\n  function _warnOrThrow(msg) {\n    var beStrict = process.env.NODE_CONFIG_STRICT_MODE;\n    var prefix = beStrict ? 'FATAL: ' : 'WARNING: ';\n    var seeURL = 'See https://github.com/lorenwest/node-config/wiki/Strict-Mode';\n    console.error(prefix + msg);\n    console.error(prefix + seeURL); // Accept 1 and true as truthy values. When set via process.env, Node.js casts them to strings.\n\n    if ([\"true\", \"1\"].indexOf(beStrict) >= 0) {\n      throw new Error(prefix + msg + ' ' + seeURL);\n    }\n  }\n}; // Instantiate and export the configuration\n\n\nvar config = module.exports = new Config(); // copy methods to util for backwards compatibility\n\nutil.stripComments = Parser.stripComments;\nutil.stripYamlComments = Parser.stripYamlComments; // Produce warnings if the configuration is empty\n\nvar showWarnings = !util.initParam('SUPPRESS_NO_CONFIG_WARNING');\n\nif (showWarnings && Object.keys(config).length === 0) {\n  console.error('WARNING: No configurations found in configuration directory:' + CONFIG_DIR);\n  console.error('WARNING: To disable this warning set SUPPRESS_NO_CONFIG_WARNING in the environment.');\n}","map":{"version":3,"names":["deferConfig","require","DeferredConfig","RawConfig","Parser","Utils","Path","FileSystem","DEFAULT_CLONE_DEPTH","NODE_CONFIG","CONFIG_DIR","RUNTIME_JSON_FILENAME","NODE_ENV","APP_INSTANCE","HOST","HOSTNAME","ALLOW_CONFIG_MUTATIONS","CONFIG_SKIP_GITCRYPT","NODE_ENV_VAR_NAME","NODE_CONFIG_PARSER","env","privateUtil","deprecationWarnings","configSources","checkMutability","gitCryptTestRegex","Config","t","fnName","util","bind","extendDeep","loadFileConfigs","attachProtoDeep","runStrictnessChecks","prototype","getImpl","object","property","elems","Array","isArray","split","name","value","length","undefined","slice","get","Error","initParam","makeImmutable","config","has","setModuleDefaults","moduleName","defaultProperties","moduleConfig","cloneDeep","splice","parsed","setPath","makeHidden","Object","defineProperty","enumerable","Buffer","isBuffer","properties","writable","configurable","keys","i","propertyName","resolve","forEach","item","index","isObject","freeze","preventExtensions","getConfigSources","getOption","options","optionName","defaultValue","configDir","node_env_var_names","node_env_var_name","join","process","cwd","indexOf","parserModule","isAbsolute","e","console","warn","log","hostName","OS","hostname","baseNames","concat","firstDomain","push","allowedFiles","resolutionIndex","extNames","getFilesOrder","baseName","extName","locatedFiles","locateMatchingFiles","fullFilename","configObj","parseFile","envConfig","JSON","parse","error","skipConfigSources","cmdLineConfig","getCmdLineArg","stringify","customEnvVars","getCustomEnvVars","runtimeJson","resolveDeferredConfigs","configDirs","delimiter","reduce","files","readdirSync","file","sort","a","b","map","deferred","_iterate","prop","propsToSort","hasOwnProperty","call","constructor","prepare","defer","configObject","fileContent","stat","readFileSync","replace","e2","code","message","test","e3","original","parseString","content","format","parser","getParser","toObject","depth","parent","circular","allParents","allChildren","useBuffer","_clone","child","isRegExp","RegExp","source","getRegExpFlags","lastIndex","isDate","Date","getTime","alloc","copy","create","getPrototypeOf","propDescriptor","getOwnPropertyDescriptor","hasGetter","isPromise","path","nextKey","shift","substituteDeep","substitutionMap","variables","result","_substituteVars","vars","pathTo","__name","parsedValue","__format","err","msg","environmentSubstitutions","equalsDeep","object1","object2","diffDeep","diff","parm","value1","value2","mergeInto","vargs","arguments","pop","mergeFrom","fromIsDeferredFunc","isDeferredFunc","_original","obj","toString","paramName","searchFor","cmdLineArgs","argv","argName","argvIt","substr","getEnv","varName","re","flags","global","ignoreCase","multiline","sources","sourceFilenames","src","basename","anyFilesMatchEnv","some","filename","match","_warnOrThrow","anyFilesMatchInstance","beStrict","NODE_CONFIG_STRICT_MODE","prefix","seeURL","module","exports","stripComments","stripYamlComments","showWarnings"],"sources":["/Users/jonathanharris/Desktop/devCodeCamp/Week9/Projects/Capstone/frontend/node_modules/config/lib/config.js"],"sourcesContent":["// config.js (c) 2010-2020 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-config\n\n// Dependencies\nvar deferConfig = require('../defer').deferConfig,\n    DeferredConfig = require('../defer').DeferredConfig,\n    RawConfig = require('../raw').RawConfig,\n    Parser = require('../parser'),\n    Utils = require('util'),\n    Path = require('path'),\n    FileSystem = require('fs');\n\n// Static members\nvar DEFAULT_CLONE_DEPTH = 20,\n    NODE_CONFIG, CONFIG_DIR, RUNTIME_JSON_FILENAME, NODE_ENV, APP_INSTANCE,\n    HOST, HOSTNAME, ALLOW_CONFIG_MUTATIONS, CONFIG_SKIP_GITCRYPT, NODE_ENV_VAR_NAME,\n    NODE_CONFIG_PARSER,\n    env = {},\n    privateUtil = {},\n    deprecationWarnings = {},\n    configSources = [],          // Configuration sources - array of {name, original, parsed}\n    checkMutability = true,      // Check for mutability/immutability on first get\n    gitCryptTestRegex = /^.GITCRYPT/; // regular expression to test for gitcrypt files.\n\n/**\n * <p>Application Configurations</p>\n *\n * <p>\n * The config module exports a singleton object representing all\n * configurations for this application deployment.\n * </p>\n *\n * <p>\n * Application configurations are stored in files within the config directory\n * of your application.  The default configuration file is loaded, followed\n * by files specific to the deployment type (development, testing, staging,\n * production, etc.).\n * </p>\n *\n * <p>\n * For example, with the following config/default.yaml file:\n * </p>\n *\n * <pre>\n *   ...\n *   customer:\n *     &nbsp;&nbsp;initialCredit: 500\n *     &nbsp;&nbsp;db:\n *       &nbsp;&nbsp;&nbsp;&nbsp;name: customer\n *       &nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n *   ...\n * </pre>\n *\n * <p>\n * The following code loads the customer section into the CONFIG variable:\n * <p>\n *\n * <pre>\n *   var CONFIG = require('config').customer;\n *   ...\n *   newCustomer.creditLimit = CONFIG.initialCredit;\n *   database.open(CONFIG.db.name, CONFIG.db.port);\n *   ...\n * </pre>\n *\n * @module config\n * @class Config\n */\n\n/**\n * <p>Get the configuration object.</p>\n *\n * <p>\n * The configuration object is a shared singleton object within the application,\n * attained by calling require('config').\n * </p>\n *\n * <p>\n * Usually you'll specify a CONFIG variable at the top of your .js file\n * for file/module scope. If you want the root of the object, you can do this:\n * </p>\n * <pre>\n * var CONFIG = require('config');\n * </pre>\n *\n * <p>\n * Sometimes you only care about a specific sub-object within the CONFIG\n * object.  In that case you could do this at the top of your file:\n * </p>\n * <pre>\n * var CONFIG = require('config').customer;\n * or\n * var CUSTOMER_CONFIG = require('config').customer;\n * </pre>\n *\n * <script type=\"text/javascript\">\n *   document.getElementById(\"showProtected\").style.display = \"block\";\n * </script>\n *\n * @method constructor\n * @return CONFIG {object} - The top level configuration object\n */\nvar Config = function() {\n  var t = this;\n\n  // Bind all utility functions to this\n  for (var fnName in util) {\n    if (typeof util[fnName] === 'function') {\n      util[fnName] = util[fnName].bind(t);\n    }\n  }\n\n  // Merge configurations into this\n  util.extendDeep(t, util.loadFileConfigs());\n  util.attachProtoDeep(t);\n\n  // Perform strictness checks and possibly throw an exception.\n  util.runStrictnessChecks(t);\n};\n\n/**\n * Utilities are under the util namespace vs. at the top level\n */\nvar util = Config.prototype.util = {};\n\n/**\n * Underlying get mechanism\n *\n * @private\n * @method getImpl\n * @param object {object} - Object to get the property for\n * @param property {string|string[]} - The property name to get (as an array or '.' delimited string)\n * @return value {*} - Property value, including undefined if not defined.\n */\nvar getImpl= function(object, property) {\n  var t = this,\n      elems = Array.isArray(property) ? property : property.split('.'),\n      name = elems[0],\n      value = object[name];\n  if (elems.length <= 1) {\n    return value;\n  }\n  // Note that typeof null === 'object'\n  if (value === null || typeof value !== 'object') {\n    return undefined;\n  }\n  return getImpl(value, elems.slice(1));\n};\n\n/**\n * <p>Get a configuration value</p>\n *\n * <p>\n * This will return the specified property value, throwing an exception if the\n * configuration isn't defined.  It is used to assure configurations are defined\n * before being used, and to prevent typos.\n * </p>\n *\n * @method get\n * @param property {string} - The configuration property to get. Can include '.' sub-properties.\n * @return value {*} - The property value\n */\nConfig.prototype.get = function(property) {\n  if(property === null || property === undefined){\n    throw new Error(\"Calling config.get with null or undefined argument\");\n  }\n\n  // Make configurations immutable after first get (unless disabled)\n  if (checkMutability) {\n    if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n      util.makeImmutable(config);\n    }\n    checkMutability = false;\n  }\n  var t = this,\n      value = getImpl(t, property);\n\n  // Produce an exception if the property doesn't exist\n  if (value === undefined) {\n    throw new Error('Configuration property \"' + property + '\" is not defined');\n  }\n\n  // Return the value\n  return value;\n};\n\n/**\n * Test that a configuration parameter exists\n *\n * <pre>\n *    var config = require('config');\n *    if (config.has('customer.dbName')) {\n *      console.log('Customer database name: ' + config.customer.dbName);\n *    }\n * </pre>\n *\n * @method has\n * @param property {string} - The configuration property to test. Can include '.' sub-properties.\n * @return isPresent {boolean} - True if the property is defined, false if not defined.\n */\nConfig.prototype.has = function(property) {\n  // While get() throws an exception for undefined input, has() is designed to test validity, so false is appropriate\n  if(property === null || property === undefined){\n    return false;\n  }\n  var t = this;\n  return (getImpl(t, property) !== undefined);\n};\n\n/**\n * <p>\n * Set default configurations for a node.js module.\n * </p>\n *\n * <p>\n * This allows module developers to attach their configurations onto the\n * default configuration object so they can be configured by the consumers\n * of the module.\n * </p>\n *\n * <p>Using the function within your module:</p>\n * <pre>\n *   var CONFIG = require(\"config\");\n *   CONFIG.util.setModuleDefaults(\"MyModule\", {\n *   &nbsp;&nbsp;templateName: \"t-50\",\n *   &nbsp;&nbsp;colorScheme: \"green\"\n *   });\n * <br>\n *   // Template name may be overridden by application config files\n *   console.log(\"Template: \" + CONFIG.MyModule.templateName);\n * </pre>\n *\n * <p>\n * The above example results in a \"MyModule\" element of the configuration\n * object, containing an object with the specified default values.\n * </p>\n *\n * @method setModuleDefaults\n * @param moduleName {string} - Name of your module.\n * @param defaultProperties {object} - The default module configuration.\n * @return moduleConfig {object} - The module level configuration object.\n */\nutil.setModuleDefaults = function (moduleName, defaultProperties) {\n\n  // Copy the properties into a new object\n  var t = this,\n    moduleConfig = util.cloneDeep(defaultProperties);\n\n  // Set module defaults into the first sources element\n  if (configSources.length === 0 || configSources[0].name !== 'Module Defaults') {\n    configSources.splice(0, 0, {\n      name: 'Module Defaults',\n      parsed: {}\n    });\n  }\n  util.setPath(configSources[0].parsed, moduleName.split('.'), {});\n  util.extendDeep(getImpl(configSources[0].parsed, moduleName), defaultProperties);\n\n  // Create a top level config for this module if it doesn't exist\n  util.setPath(t, moduleName.split('.'), getImpl(t, moduleName) || {});\n\n  // Extend local configurations into the module config\n  util.extendDeep(moduleConfig, getImpl(t, moduleName));\n\n  // Merge the extended configs without replacing the original\n  util.extendDeep(getImpl(t, moduleName), moduleConfig);\n\n  // reset the mutability check for \"config.get\" method.\n  // we are not making t[moduleName] immutable immediately,\n  // since there might be more modifications before the first config.get\n  if (!util.initParam('ALLOW_CONFIG_MUTATIONS', false)) {\n    checkMutability = true;\n  }\n\n  // Attach handlers & watchers onto the module config object\n  return util.attachProtoDeep(getImpl(t, moduleName));\n};\n\n/**\n * <p>Make a configuration property hidden so it doesn't appear when enumerating\n * elements of the object.</p>\n *\n * <p>\n * The property still exists and can be read from and written to, but it won't\n * show up in for ... in loops, Object.keys(), or JSON.stringify() type methods.\n * </p>\n *\n * <p>\n * If the property already exists, it will be made hidden.  Otherwise it will\n * be created as a hidden property with the specified value.\n * </p>\n *\n * <p><i>\n * This method was built for hiding configuration values, but it can be applied\n * to <u>any</u> javascript object.\n * </i></p>\n *\n * <p>Example:</p>\n * <pre>\n *   var CONFIG = require('config');\n *   ...\n *\n *   // Hide the Amazon S3 credentials\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'access_id');\n *   CONFIG.util.makeHidden(CONFIG.amazonS3, 'secret_key');\n * </pre>\n *\n * @method makeHidden\n * @param object {object} - The object to make a hidden property into.\n * @param property {string} - The name of the property to make hidden.\n * @param value {*} - (optional) Set the property value to this (otherwise leave alone)\n * @return object {object} - The original object is returned - for chaining.\n */\nutil.makeHidden = function(object, property, value) {\n\n  // If the new value isn't specified, just mark the property as hidden\n  if (typeof value === 'undefined') {\n    Object.defineProperty(object, property, {\n      enumerable : false\n    });\n  }\n  // Otherwise set the value and mark it as hidden\n  else {\n    Object.defineProperty(object, property, {\n      value      : value,\n      enumerable : false\n    });\n  }\n\n  return object;\n}\n\n/**\n * <p>Make a javascript object property immutable (assuring it cannot be changed\n * from the current value).</p>\n * <p>\n * If the specified property is an object, all attributes of that object are\n * made immutable, including properties of contained objects, recursively.\n * If a property name isn't supplied, all properties of the object are made\n * immutable.\n * </p>\n * <p>\n *\n * </p>\n * <p>\n * New properties can be added to the object and those properties will not be\n * immutable unless this method is called on those new properties.\n * </p>\n * <p>\n * This operation cannot be undone.\n * </p>\n *\n * <p>Example:</p>\n * <pre>\n *   var config = require('config');\n *   var myObject = {hello:'world'};\n *   config.util.makeImmutable(myObject);\n * </pre>\n *\n * @method makeImmutable\n * @param object {object} - The object to specify immutable properties for\n * @param [property] {string | [string]} - The name of the property (or array of names) to make immutable.\n *        If not provided, all owned properties of the object are made immutable.\n * @param [value] {* | [*]} - Property value (or array of values) to set\n *        the property to before making immutable. Only used when setting a single\n *        property. Retained for backward compatibility.\n * @return object {object} - The original object is returned - for chaining.\n */\nutil.makeImmutable = function(object, property, value) {\n  if (Buffer.isBuffer(object)) {\n    return object;\n  }\n  var properties = null;\n\n  // Backwards compatibility mode where property/value can be specified\n  if (typeof property === 'string') {\n    return Object.defineProperty(object, property, {\n      value : (typeof value === 'undefined') ? object[property] : value,\n      writable : false,\n      configurable: false\n    });\n  }\n\n  // Get the list of properties to work with\n  if (Array.isArray(property)) {\n    properties = property;\n  }\n  else {\n    properties = Object.keys(object);\n  }\n\n  // Process each property\n  for (var i = 0; i < properties.length; i++) {\n    var propertyName = properties[i],\n        value = object[propertyName];\n\n    if (value instanceof RawConfig) {\n      Object.defineProperty(object, propertyName, {\n        value: value.resolve(),\n        writable: false,\n        configurable: false\n      });\n    } else if (Array.isArray(value)) {\n      // Ensure object items of this array are also immutable.\n      value.forEach((item, index) => { if (util.isObject(item) || Array.isArray(item)) util.makeImmutable(item) })\n\n      Object.defineProperty(object, propertyName, {\n        value: Object.freeze(value)\n      });\n    } else {\n      Object.defineProperty(object, propertyName, {\n        value: value,\n        writable : false,\n        configurable: false\n      });\n\n      // Ensure new properties can not be added.\n      Object.preventExtensions(object)\n\n      // Call recursively if an object.\n      if (util.isObject(value)) {\n        util.makeImmutable(value);\n      }\n    }\n  }\n\n  return object;\n};\n\n/**\n * Return the sources for the configurations\n *\n * <p>\n * All sources for configurations are stored in an array of objects containing\n * the source name (usually the filename), the original source (as a string),\n * and the parsed source as an object.\n * </p>\n *\n * @method getConfigSources\n * @return configSources {Array[Object]} - An array of objects containing\n *    name, original, and parsed elements\n */\nutil.getConfigSources = function() {\n  var t = this;\n  return configSources.slice(0);\n};\n\n/**\n * Looks into an options object for a specific attribute\n *\n * <p>\n * This method looks into the options object, and if an attribute is defined, returns it,\n * and if not, returns the default value\n * </p>\n *\n * @method getOption\n * @param options {Object | undefined} the options object\n * @param optionName {string} the attribute name to look for\n * @param defaultValue { any } the default in case the options object is empty, or the attribute does not exist.\n * @return options[optionName] if defined, defaultValue if not.\n */\nutil.getOption = function(options, optionName, defaultValue) {\n  if (options !== undefined && options[optionName] !== undefined){\n    return options[optionName];\n  } else {\n    return defaultValue;\n  }\n};\n\n\n/**\n * Load the individual file configurations.\n *\n * <p>\n * This method builds a map of filename to the configuration object defined\n * by the file.  The search order is:\n * </p>\n *\n * <pre>\n *   default.EXT\n *   (deployment).EXT\n *   (hostname).EXT\n *   (hostname)-(deployment).EXT\n *   local.EXT\n *   local-(deployment).EXT\n *   runtime.json\n * </pre>\n *\n * <p>\n * EXT can be yml, yaml, coffee, iced, json, cson or js signifying the file type.\n * yaml (and yml) is in YAML format, coffee is a coffee-script, iced is iced-coffee-script,\n * json is in JSON format, cson is in CSON format, properties is in .properties format\n * (http://en.wikipedia.org/wiki/.properties), and js is a javascript executable file that is\n * require()'d with module.exports being the config object.\n * </p>\n *\n * <p>\n * hostname is the $HOST environment variable (or --HOST command line parameter)\n * if set, otherwise the $HOSTNAME environment variable (or --HOSTNAME command\n * line parameter) if set, otherwise the hostname found from\n * require('os').hostname().\n * </p>\n *\n * <p>\n * Once a hostname is found, everything from the first period ('.') onwards\n * is removed. For example, abc.example.com becomes abc\n * </p>\n *\n * <p>\n * (deployment) is the deployment type, found in the $NODE_ENV environment\n * variable (which can be overridden by using $NODE_CONFIG_ENV\n * environment variable). Defaults to 'development'.\n * </p>\n *\n * <p>\n * The runtime.json file contains configuration changes made at runtime either\n * manually, or by the application setting a configuration value.\n * </p>\n *\n * <p>\n * If the $NODE_APP_INSTANCE environment variable (or --NODE_APP_INSTANCE\n * command line parameter) is set, then files with this appendage will be loaded.\n * See the Multiple Application Instances section of the main documentation page\n * for more information.\n * </p>\n *\n * @protected\n * @method loadFileConfigs\n * @param configDir { string | null } the path to the directory containing the configurations to load\n * @param options { object | undefined } parsing options. Current supported option: skipConfigSources: true|false\n * @return config {Object} The configuration object\n */\nutil.loadFileConfigs = function(configDir, options) {\n\n  // Initialize\n  var t = this,\n      config = {};\n\n  // Specify variables that can be used to define the environment\n  var node_env_var_names = ['NODE_CONFIG_ENV', 'NODE_ENV'];\n\n  // Loop through the variables to try and set environment\n  for (const node_env_var_name of node_env_var_names) {\n    NODE_ENV = util.initParam(node_env_var_name);\n    if (!!NODE_ENV) {\n      NODE_ENV_VAR_NAME = node_env_var_name;\n      break;\n    }\n  }\n\n  // If we haven't successfully set the environment using the variables, we'll default it\n  if (!NODE_ENV) {\n    NODE_ENV = 'development';\n  }\n\n  node_env_var_names.forEach(node_env_var_name => {\n    env[node_env_var_name] = NODE_ENV;\n  });\n\n  // Split files name, for loading multiple files.\n  NODE_ENV = NODE_ENV.split(',');\n\n  CONFIG_DIR = configDir || util.initParam('NODE_CONFIG_DIR', Path.join( process.cwd(), 'config') );\n  if (CONFIG_DIR.indexOf('.') === 0) {\n    CONFIG_DIR = Path.join(process.cwd() , CONFIG_DIR);\n  }\n\n  APP_INSTANCE = util.initParam('NODE_APP_INSTANCE');\n  HOST = util.initParam('HOST');\n  HOSTNAME = util.initParam('HOSTNAME');\n  CONFIG_SKIP_GITCRYPT = util.initParam('CONFIG_SKIP_GITCRYPT');\n\n  // This is for backward compatibility\n  RUNTIME_JSON_FILENAME = util.initParam('NODE_CONFIG_RUNTIME_JSON', Path.join(CONFIG_DIR , 'runtime.json') );\n\n  NODE_CONFIG_PARSER = util.initParam('NODE_CONFIG_PARSER');\n  if (NODE_CONFIG_PARSER) {\n    try {\n      var parserModule = Path.isAbsolute(NODE_CONFIG_PARSER)\n        ? NODE_CONFIG_PARSER\n        : Path.join(CONFIG_DIR, NODE_CONFIG_PARSER);\n      Parser = require(parserModule);\n    }\n    catch (e) {\n      console.warn('Failed to load config parser from ' + NODE_CONFIG_PARSER);\n      console.log(e);\n    }\n  }\n\n  // Determine the host name from the OS module, $HOST, or $HOSTNAME\n  // Remove any . appendages, and default to null if not set\n  try {\n    var hostName = HOST || HOSTNAME;\n\n    if (!hostName) {\n        var OS = require('os');\n        hostName = OS.hostname();\n    }\n  } catch (e) {\n    hostName = '';\n  }\n\n  // Store the hostname that won.\n  env.HOSTNAME = hostName;\n\n  // Read each file in turn\n  var baseNames = ['default'].concat(NODE_ENV);\n\n  // #236: Also add full hostname when they are different.\n  if (hostName) {\n    var firstDomain = hostName.split('.')[0];\n\n    NODE_ENV.forEach(function(env) {\n      // Backward compatibility\n      baseNames.push(firstDomain, firstDomain + '-' + env);\n\n      // Add full hostname when it is not the same\n      if (hostName !== firstDomain) {\n        baseNames.push(hostName, hostName + '-' + env);\n      }\n    });\n  }\n\n  NODE_ENV.forEach(function(env) {\n    baseNames.push('local', 'local-' + env);\n  });\n\n  var allowedFiles = {};\n  var resolutionIndex = 1;\n  var extNames = Parser.getFilesOrder();\n  baseNames.forEach(function(baseName) {\n    extNames.forEach(function(extName) {\n      allowedFiles[baseName + '.' + extName] = resolutionIndex++;\n      if (APP_INSTANCE) {\n        allowedFiles[baseName + '-' + APP_INSTANCE + '.' + extName] = resolutionIndex++;\n      }\n    });\n  });\n\n  var locatedFiles = util.locateMatchingFiles(CONFIG_DIR, allowedFiles);\n  locatedFiles.forEach(function(fullFilename) {\n    var configObj = util.parseFile(fullFilename, options);\n    if (configObj) {\n      util.extendDeep(config, configObj);\n    }\n  });\n\n  // Override configurations from the $NODE_CONFIG environment variable\n  // NODE_CONFIG only applies to the base config\n  if (!configDir) {\n    var envConfig = {};\n    if (process.env.NODE_CONFIG) {\n      try {\n        envConfig = JSON.parse(process.env.NODE_CONFIG);\n      } catch(e) {\n        console.error('The $NODE_CONFIG environment variable is malformed JSON');\n      }\n      util.extendDeep(config, envConfig);\n      var skipConfigSources = util.getOption(options,'skipConfigSources', false);\n      if (!skipConfigSources){\n        configSources.push({\n          name: \"$NODE_CONFIG\",\n          parsed: envConfig,\n        });\n      }\n    }\n\n    // Override configurations from the --NODE_CONFIG command line\n    var cmdLineConfig = util.getCmdLineArg('NODE_CONFIG');\n    if (cmdLineConfig) {\n      try {\n        cmdLineConfig = JSON.parse(cmdLineConfig);\n      } catch(e) {\n        console.error('The --NODE_CONFIG={json} command line argument is malformed JSON');\n      }\n      util.extendDeep(config, cmdLineConfig);\n      var skipConfigSources = util.getOption(options,'skipConfigSources', false);\n      if (!skipConfigSources){\n        configSources.push({\n          name: \"--NODE_CONFIG argument\",\n          parsed: cmdLineConfig,\n        });\n      }\n    }\n\n    // Place the mixed NODE_CONFIG into the environment\n    env['NODE_CONFIG'] = JSON.stringify(util.extendDeep(envConfig, cmdLineConfig, {}));\n  }\n\n  // Override with environment variables if there is a custom-environment-variables.EXT mapping file\n  var customEnvVars = util.getCustomEnvVars(CONFIG_DIR, extNames);\n  util.extendDeep(config, customEnvVars);\n\n  // Extend the original config with the contents of runtime.json (backwards compatibility)\n  var runtimeJson = util.parseFile(RUNTIME_JSON_FILENAME) || {};\n  util.extendDeep(config, runtimeJson);\n\n  util.resolveDeferredConfigs(config);\n\n  // Return the configuration object\n  return config;\n};\n\n/**\n * Return a list of fullFilenames who exists in allowedFiles\n * Ordered according to allowedFiles argument specifications\n *\n * @protected\n * @method locateMatchingFiles\n * @param configDirs {string}   the config dir, or multiple dirs separated by a column (:)\n * @param allowedFiles {object} an object. keys and supported filenames\n *                              and values are the position in the resolution order\n * @returns {string[]}          fullFilenames - path + filename\n */\nutil.locateMatchingFiles = function(configDirs, allowedFiles) {\n  return configDirs.split(Path.delimiter)\n    .reduce(function(files, configDir) {\n      if (configDir) {\n        try {\n          FileSystem.readdirSync(configDir).forEach(function(file) {\n            if (allowedFiles[file]) {\n              files.push([allowedFiles[file], Path.join(configDir, file)]);\n            }\n          });\n        }\n        catch(e) {}\n        return files;\n      }\n    }, [])\n    .sort(function(a, b) { return a[0] - b[0]; })\n    .map(function(file) { return file[1]; });\n};\n\n// Using basic recursion pattern, find all the deferred values and resolve them.\nutil.resolveDeferredConfigs = function (config) {\n  var deferred = [];\n\n  function _iterate (prop) {\n\n    // We put the properties we are going to look it in an array to keep the order predictable\n    var propsToSort = [];\n\n    // First step is to put the properties of interest in an array\n    for (var property in prop) {\n      if (Object.hasOwnProperty.call(prop, property) && prop[property] != null) {\n        propsToSort.push(property);\n      }\n    }\n\n    // Second step is to iterate of the elements in a predictable (sorted) order\n    propsToSort.sort().forEach(function (property) {\n      if (prop[property].constructor === Object) {\n        _iterate(prop[property]);\n      } else if (prop[property].constructor === Array) {\n        for (var i = 0; i < prop[property].length; i++) {\n          if (prop[property][i] instanceof DeferredConfig) {\n            deferred.push(prop[property][i].prepare(config, prop[property], i));\n          }\n          else {\n            _iterate(prop[property][i]);\n          }\n        }\n      } else {\n        if (prop[property] instanceof DeferredConfig) {\n          deferred.push(prop[property].prepare(config, prop, property));\n        }\n        // else: Nothing to do. Keep the property how it is.\n      }\n    });\n  }\n\n  _iterate(config);\n\n  deferred.forEach(function (defer) { defer.resolve(); });\n};\n\n/**\n * Parse and return the specified configuration file.\n *\n * If the file exists in the application config directory, it will\n * parse and return it as a JavaScript object.\n *\n * The file extension determines the parser to use.\n *\n * .js = File to run that has a module.exports containing the config object\n * .coffee = File to run that has a module.exports with coffee-script containing the config object\n * .iced = File to run that has a module.exports with iced-coffee-script containing the config object\n * All other supported file types (yaml, toml, json, cson, hjson, json5, properties, xml)\n * are parsed with util.parseString.\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseFile\n * @param fullFilename {string} The full file path and name\n * @param options { object | undefined } parsing options. Current supported option: skipConfigSources: true|false\n * @return configObject {object|null} The configuration object parsed from the file\n */\nutil.parseFile = function(fullFilename, options) {\n  var t = this,  // Initialize\n      configObject = null,\n      fileContent = null,\n      stat = null;\n\n  // Note that all methods here are the Sync versions.  This is appropriate during\n  // module loading (which is a synchronous operation), but not thereafter.\n\n  try {\n    // Try loading the file.\n    fileContent = FileSystem.readFileSync(fullFilename, 'utf-8');\n    fileContent = fileContent.replace(/^\\uFEFF/, '');\n  }\n  catch (e2) {\n    if (e2.code !== 'ENOENT') {\n      throw new Error('Config file ' + fullFilename + ' cannot be read. Error code is: '+e2.code\n                        +'. Error message is: '+e2.message);\n    }\n    return null;  // file doesn't exists\n  }\n\n  // Parse the file based on extension\n  try {\n\n    // skip if it's a gitcrypt file and CONFIG_SKIP_GITCRYPT is true\n    if (CONFIG_SKIP_GITCRYPT) {\n      if (gitCryptTestRegex.test(fileContent)) {\n        console.error('WARNING: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is set. skipping.');\n        return null;\n      }\n    }\n\n    configObject = Parser.parse(fullFilename, fileContent);\n  }\n  catch (e3) {\n    if (gitCryptTestRegex.test(fileContent)) {\n      console.error('ERROR: ' + fullFilename + ' is a git-crypt file and CONFIG_SKIP_GITCRYPT is not set.');\n    }\n    throw new Error(\"Cannot parse config file: '\" + fullFilename + \"': \" + e3);\n  }\n\n  // Keep track of this configuration sources, including empty ones, unless the skipConfigSources flag is set to true in the options\n  var skipConfigSources = util.getOption(options,'skipConfigSources', false);\n  if (typeof configObject === 'object' && !skipConfigSources) {\n    configSources.push({\n      name: fullFilename,\n      original: fileContent,\n      parsed: configObject,\n    });\n  }\n\n  return configObject;\n};\n\n/**\n * Parse and return the specified string with the specified format.\n *\n * The format determines the parser to use.\n *\n * json = File is parsed using JSON.parse()\n * yaml (or yml) = Parsed with a YAML parser\n * toml = Parsed with a TOML parser\n * cson = Parsed with a CSON parser\n * hjson = Parsed with a HJSON parser\n * json5 = Parsed with a JSON5 parser\n * properties = Parsed with the 'properties' node package\n * xml = Parsed with a XML parser\n *\n * If the file doesn't exist, a null will be returned.  If the file can't be\n * parsed, an exception will be thrown.\n *\n * This method performs synchronous file operations, and should not be called\n * after synchronous module loading.\n *\n * @protected\n * @method parseString\n * @param content {string} The full content\n * @param format {string} The format to be parsed\n * @return {configObject} The configuration object parsed from the string\n */\nutil.parseString = function (content, format) {\n  var parser = Parser.getParser(format);\n  if (typeof parser === 'function') {\n    return parser(null, content);\n  }\n};\n\n/**\n * Attach the Config class prototype to all config objects recursively.\n *\n * <p>\n * This allows you to do anything with CONFIG sub-objects as you can do with\n * the top-level CONFIG object.  It's so you can do this:\n * </p>\n *\n * <pre>\n *   var CUST_CONFIG = require('config').Customer;\n *   CUST_CONFIG.get(...)\n * </pre>\n *\n * @protected\n * @method attachProtoDeep\n * @param toObject\n * @param depth\n * @return toObject\n */\nutil.attachProtoDeep = function(toObject, depth) {\n  if (toObject instanceof RawConfig) {\n    return toObject;\n  }\n\n  // Recursion detection\n  var t = this;\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return toObject;\n  }\n\n  // Adding Config.prototype methods directly to toObject as hidden properties\n  // because adding to toObject.__proto__ exposes the function in toObject\n  for (var fnName in Config.prototype) {\n    if (!toObject[fnName]) {\n      util.makeHidden(toObject, fnName, Config.prototype[fnName]);\n    }\n  }\n\n  // Add prototypes to sub-objects\n  for (var prop in toObject) {\n    if (util.isObject(toObject[prop])) {\n      util.attachProtoDeep(toObject[prop], depth - 1);\n    }\n  }\n\n  // Return the original object\n  return toObject;\n};\n\n/**\n * Return a deep copy of the specified object.\n *\n * This returns a new object with all elements copied from the specified\n * object.  Deep copies are made of objects and arrays so you can do anything\n * with the returned object without affecting the input object.\n *\n * @protected\n * @method cloneDeep\n * @param parent {object} The original object to copy from\n * @param [depth=20] {Integer} Maximum depth (default 20)\n * @return {object} A new object with the elements copied from the copyFrom object\n *\n * This method is copied from https://github.com/pvorb/node-clone/blob/17eea36140d61d97a9954c53417d0e04a00525d9/clone.js\n *\n * Copyright © 2011-2014 Paul Vorbach and contributors.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions: The above copyright notice and this permission\n * notice shall be included in all copies or substantial portions of the Software.\n */\nutil.cloneDeep = function cloneDeep(parent, depth, circular, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular === 'undefined')\n    circular = true;\n\n  if (typeof depth === 'undefined')\n    depth = 20;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (Utils.isArray(parent)) {\n      child = [];\n    } else if (Utils.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (Utils.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = Buffer.alloc(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype === 'undefined') child = Object.create(Object.getPrototypeOf(parent));\n      else child = Object.create(prototype);\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var propDescriptor  = Object.getOwnPropertyDescriptor(parent,i);\n      var hasGetter = ((propDescriptor !== undefined) && (propDescriptor.get !== undefined));\n\n      if (hasGetter){\n        Object.defineProperty(child,i,propDescriptor);\n      } else if (util.isPromise(parent[i])) {\n        child[i] = parent[i];\n      } else {\n        child[i] = _clone(parent[i], depth - 1);\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n};\n\n/**\n * Set objects given a path as a string list\n *\n * @protected\n * @method setPath\n * @param object {object} - Object to set the property on\n * @param path {array[string]} - Array path to the property\n * @param value {*} - value to set, ignoring null\n */\nutil.setPath = function (object, path, value) {\n  var nextKey = null;\n  if (value === null || path.length === 0) {\n    return;\n  }\n  else if (path.length === 1) { // no more keys to make, so set the value\n    object[path.shift()] = value;\n  }\n  else {\n    nextKey = path.shift();\n    if (!Object.hasOwnProperty.call(object, nextKey)) {\n      object[nextKey] = {};\n    }\n    util.setPath(object[nextKey], path, value);\n  }\n};\n\n/**\n * Create a new object patterned after substitutionMap, where:\n * 1. Terminal string values in substitutionMap are used as keys\n * 2. To look up values in a key-value store, variables\n * 3. And parent keys are created as necessary to retain the structure of substitutionMap.\n *\n * @protected\n * @method substituteDeep\n * @param substitutionMap {object} - an object whose terminal (non-subobject) values are strings\n * @param variables {object[string:value]} - usually process.env, a flat object used to transform\n *      terminal values in a copy of substitutionMap.\n * @returns {object} - deep copy of substitutionMap with only those paths whose terminal values\n *      corresponded to a key in `variables`\n */\nutil.substituteDeep = function (substitutionMap, variables) {\n  var result = {};\n\n  function _substituteVars(map, vars, pathTo) {\n    for (var prop in map) {\n      var value = map[prop];\n      if (typeof(value) === 'string') { // We found a leaf variable name\n        if (vars[value] !== undefined && vars[value] !== '') { // if the vars provide a value set the value in the result map\n          util.setPath(result, pathTo.concat(prop), vars[value]);\n        }\n      }\n      else if (util.isObject(value)) { // work on the subtree, giving it a clone of the pathTo\n        if ('__name' in value && '__format' in value && vars[value.__name] !== undefined && vars[value.__name] !== '') {\n          try {\n            var parsedValue = util.parseString(vars[value.__name], value.__format);\n          } catch(err) {\n            err.message = '__format parser error in ' + value.__name + ': ' + err.message;\n            throw err;\n          }\n          util.setPath(result, pathTo.concat(prop), parsedValue);\n        } else {\n          _substituteVars(value, vars, pathTo.concat(prop));\n        }\n      }\n      else {\n        msg = \"Illegal key type for substitution map at \" + pathTo.join('.') + ': ' + typeof(value);\n        throw Error(msg);\n      }\n    }\n  }\n\n  _substituteVars(substitutionMap, variables, []);\n  return result;\n\n};\n\n/* Map environment variables into the configuration if a mapping file,\n * `custom-environment-variables.EXT` exists.\n *\n * @protected\n * @method getCustomEnvVars\n * @param CONFIG_DIR {string} - the passed configuration directory\n * @param extNames {Array[string]} - acceptable configuration file extension names.\n * @returns {object} - mapped environment variables or {} if there are none\n */\nutil.getCustomEnvVars = function (CONFIG_DIR, extNames) {\n  var result = {};\n  var resolutionIndex = 1;\n  var allowedFiles = {};\n  extNames.forEach(function (extName) {\n    allowedFiles['custom-environment-variables' + '.' + extName] = resolutionIndex++;\n  });\n  var locatedFiles = util.locateMatchingFiles(CONFIG_DIR, allowedFiles);\n  locatedFiles.forEach(function (fullFilename) {\n    var configObj = util.parseFile(fullFilename);\n    if (configObj) {\n      var environmentSubstitutions = util.substituteDeep(configObj, process.env);\n      util.extendDeep(result, environmentSubstitutions);\n    }\n  });\n  return result;\n};\n\n/**\n * Return true if two objects have equal contents.\n *\n * @protected\n * @method equalsDeep\n * @param object1 {object} The object to compare from\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {boolean} True if both objects have equivalent contents\n */\nutil.equalsDeep = function(object1, object2, depth) {\n\n  // Recursion detection\n  var t = this;\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return {};\n  }\n\n  // Fast comparisons\n  if (!object1 || !object2) {\n    return false;\n  }\n  if (object1 === object2) {\n    return true;\n  }\n  if (typeof(object1) != 'object' || typeof(object2) != 'object') {\n    return false;\n  }\n\n  // They must have the same keys.  If their length isn't the same\n  // then they're not equal.  If the keys aren't the same, the value\n  // comparisons will fail.\n  if (Object.keys(object1).length != Object.keys(object2).length) {\n    return false;\n  }\n\n  // Compare the values\n  for (var prop in object1) {\n\n    // Call recursively if an object or array\n    if (object1[prop] && typeof(object1[prop]) === 'object') {\n      if (!util.equalsDeep(object1[prop], object2[prop], depth - 1)) {\n        return false;\n      }\n    }\n    else {\n      if (object1[prop] !== object2[prop]) {\n        return false;\n      }\n    }\n  }\n\n  // Test passed.\n  return true;\n};\n\n/**\n * Returns an object containing all elements that differ between two objects.\n * <p>\n * This method was designed to be used to create the runtime.json file\n * contents, but can be used to get the diffs between any two Javascript objects.\n * </p>\n * <p>\n * It works best when object2 originated by deep copying object1, then\n * changes were made to object2, and you want an object that would give you\n * the changes made to object1 which resulted in object2.\n * </p>\n *\n * @protected\n * @method diffDeep\n * @param object1 {object} The base object to compare to\n * @param object2 {object} The object to compare with\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} A differential object, which if extended onto object1 would\n *                  result in object2.\n */\nutil.diffDeep = function(object1, object2, depth) {\n\n  // Recursion detection\n  var t = this, diff = {};\n  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);\n  if (depth < 0) {\n    return {};\n  }\n\n  // Process each element from object2, adding any element that's different\n  // from object 1.\n  for (var parm in object2) {\n    var value1 = object1[parm];\n    var value2 = object2[parm];\n    if (value1 && value2 && util.isObject(value2)) {\n      if (!(util.equalsDeep(value1, value2))) {\n        diff[parm] = util.diffDeep(value1, value2, depth - 1);\n      }\n    }\n    else if (Array.isArray(value1) && Array.isArray(value2)) {\n      if(!util.equalsDeep(value1, value2)) {\n        diff[parm] = value2;\n      }\n    }\n    else if (value1 !== value2){\n      diff[parm] = value2;\n    }\n  }\n\n  // Return the diff object\n  return diff;\n\n};\n\n/**\n * Extend an object, and any object it contains.\n *\n * This does not replace deep objects, but dives into them\n * replacing individual elements instead.\n *\n * @protected\n * @method extendDeep\n * @param mergeInto {object} The object to merge into\n * @param mergeFrom... {object...} - Any number of objects to merge from\n * @param depth {integer} An optional depth to prevent recursion.  Default: 20.\n * @return {object} The altered mergeInto object is returned\n */\nutil.extendDeep = function(mergeInto) {\n\n  // Initialize\n  var t = this;\n  var vargs = Array.prototype.slice.call(arguments, 1);\n  var depth = vargs.pop();\n  if (typeof(depth) != 'number') {\n    vargs.push(depth);\n    depth = DEFAULT_CLONE_DEPTH;\n  }\n\n  // Recursion detection\n  if (depth < 0) {\n    return mergeInto;\n  }\n\n  // Cycle through each object to extend\n  vargs.forEach(function(mergeFrom) {\n\n    // Cycle through each element of the object to merge from\n    for (var prop in mergeFrom) {\n\n      // save original value in deferred elements\n      var fromIsDeferredFunc = mergeFrom[prop] instanceof DeferredConfig;\n      var isDeferredFunc = mergeInto[prop] instanceof DeferredConfig;\n\n      if (fromIsDeferredFunc && Object.hasOwnProperty.call(mergeInto, prop)) {\n        mergeFrom[prop]._original = isDeferredFunc ? mergeInto[prop]._original : mergeInto[prop];\n      }\n      // Extend recursively if both elements are objects and target is not really a deferred function\n      if (mergeFrom[prop] instanceof Date) {\n        mergeInto[prop] = mergeFrom[prop];\n      } if (mergeFrom[prop] instanceof RegExp) {\n        mergeInto[prop] = mergeFrom[prop];\n      } else if (util.isObject(mergeInto[prop]) && util.isObject(mergeFrom[prop]) && !isDeferredFunc) {\n        util.extendDeep(mergeInto[prop], mergeFrom[prop], depth - 1);\n      }\n      else if (util.isPromise(mergeFrom[prop])) {\n        mergeInto[prop] = mergeFrom[prop];\n      }\n      // Copy recursively if the mergeFrom element is an object (or array or fn)\n      else if (mergeFrom[prop] && typeof mergeFrom[prop] === 'object') {\n        mergeInto[prop] = util.cloneDeep(mergeFrom[prop], depth -1);\n      }\n\n      // Copy property descriptor otherwise, preserving accessors\n      else if (Object.getOwnPropertyDescriptor(Object(mergeFrom), prop)){\n          Object.defineProperty(mergeInto, prop, Object.getOwnPropertyDescriptor(Object(mergeFrom), prop));\n      } else {\n          mergeInto[prop] = mergeFrom[prop];\n      }\n    }\n  });\n\n  // Chain\n  return mergeInto;\n\n};\n\n/**\n * Is the specified argument a regular javascript object?\n *\n * The argument is an object if it's a JS object, but not an array.\n *\n * @protected\n * @method isObject\n * @param obj {*} An argument of any type.\n * @return {boolean} TRUE if the arg is an object, FALSE if not\n */\nutil.isObject = function(obj) {\n  return (obj !== null) && (typeof obj === 'object') && !(Array.isArray(obj));\n};\n\n/**\n * Is the specified argument a javascript promise?\n *\n * @protected\n * @method isPromise\n * @param obj {*} An argument of any type.\n * @returns {boolean}\n */\nutil.isPromise = function(obj) {\n  return Object.prototype.toString.call(obj) === '[object Promise]';\n};\n\n/**\n * <p>Initialize a parameter from the command line or process environment</p>\n *\n * <p>\n * This method looks for the parameter from the command line in the format\n * --PARAMETER=VALUE, then from the process environment, then from the\n * default specified as an argument.\n * </p>\n *\n * @method initParam\n * @param paramName {String} Name of the parameter\n * @param [defaultValue] {Any} Default value of the parameter\n * @return {Any} The found value, or default value\n */\nutil.initParam = function (paramName, defaultValue) {\n  var t = this;\n\n  // Record and return the value\n  var value = util.getCmdLineArg(paramName) || process.env[paramName] || defaultValue;\n  env[paramName] = value;\n  return value;\n}\n\n/**\n * <p>Get Command Line Arguments</p>\n *\n * <p>\n * This method allows you to retrieve the value of the specified command line argument.\n * </p>\n *\n * <p>\n * The argument is case sensitive, and must be of the form '--ARG_NAME=value'\n * </p>\n *\n * @method getCmdLineArg\n * @param searchFor {String} The argument name to search for\n * @return {*} false if the argument was not found, the argument value if found\n */\nutil.getCmdLineArg = function (searchFor) {\n    var cmdLineArgs = process.argv.slice(2, process.argv.length),\n        argName = '--' + searchFor + '=';\n\n    for (var argvIt = 0; argvIt < cmdLineArgs.length; argvIt++) {\n      if (cmdLineArgs[argvIt].indexOf(argName) === 0) {\n        return cmdLineArgs[argvIt].substr(argName.length);\n      }\n    }\n\n    return false;\n}\n\n/**\n * <p>Get a Config Environment Variable Value</p>\n *\n * <p>\n * This method returns the value of the specified config environment variable,\n * including any defaults or overrides.\n * </p>\n *\n * @method getEnv\n * @param varName {String} The environment variable name\n * @return {String} The value of the environment variable\n */\nutil.getEnv = function (varName) {\n  return env[varName];\n}\n\n\n\n/**\n * Returns a string of flags for regular expression `re`.\n *\n * @param {RegExp} re Regular expression\n * @returns {string} Flags\n */\nutil.getRegExpFlags = function (re) {\n  var flags = '';\n  re.global && (flags += 'g');\n  re.ignoreCase && (flags += 'i');\n  re.multiline && (flags += 'm');\n  return flags;\n};\n\n/**\n * Returns a new deep copy of the current config object, or any part of the config if provided.\n *\n * @param {Object} config The part of the config to copy and serialize. Omit this argument to return the entire config.\n * @returns {Object} The cloned config or part of the config\n */\nutil.toObject = function(config) {\n  return JSON.parse(JSON.stringify(config || this));\n};\n\n// Run strictness checks on NODE_ENV and NODE_APP_INSTANCE and throw an error if there's a problem.\nutil.runStrictnessChecks = function (config) {\n  var sources = config.util.getConfigSources();\n\n  var sourceFilenames = sources.map(function (src) {\n    return Path.basename(src.name);\n  });\n\n  NODE_ENV.forEach(function(env) {\n    // Throw an exception if there's no explicit config file for NODE_ENV\n    var anyFilesMatchEnv = sourceFilenames.some(function (filename) {\n        return filename.match(env);\n    });\n    // development is special-cased because it's the default value\n    if (env && (env !== 'development') && !anyFilesMatchEnv) {\n      _warnOrThrow(NODE_ENV_VAR_NAME+\" value of '\"+env+\"' did not match any deployment config file names.\");\n    }\n    // Throw if NODE_ENV matches' default' or 'local'\n    if ((env === 'default') || (env === 'local')) {\n      _warnOrThrow(NODE_ENV_VAR_NAME+\" value of '\"+env+\"' is ambiguous.\");\n    }\n  });\n\n  // Throw an exception if there's no explicit config file for NODE_APP_INSTANCE\n  var anyFilesMatchInstance = sourceFilenames.some(function (filename) {\n      return filename.match(APP_INSTANCE);\n  });\n  if (APP_INSTANCE && !anyFilesMatchInstance) {\n    _warnOrThrow(\"NODE_APP_INSTANCE value of '\"+APP_INSTANCE+\"' did not match any instance config file names.\");\n  }\n\n  function _warnOrThrow (msg) {\n    var beStrict = process.env.NODE_CONFIG_STRICT_MODE;\n    var prefix = beStrict ? 'FATAL: ' : 'WARNING: ';\n    var seeURL = 'See https://github.com/lorenwest/node-config/wiki/Strict-Mode';\n\n    console.error(prefix+msg);\n    console.error(prefix+seeURL);\n\n    // Accept 1 and true as truthy values. When set via process.env, Node.js casts them to strings.\n    if ([\"true\", \"1\"].indexOf(beStrict) >= 0) {\n      throw new Error(prefix+msg+' '+seeURL);\n    }\n  }\n};\n\n// Instantiate and export the configuration\nvar config = module.exports = new Config();\n\n// copy methods to util for backwards compatibility\nutil.stripComments = Parser.stripComments;\nutil.stripYamlComments = Parser.stripYamlComments;\n\n// Produce warnings if the configuration is empty\nvar showWarnings = !(util.initParam('SUPPRESS_NO_CONFIG_WARNING'));\nif (showWarnings && Object.keys(config).length === 0) {\n  console.error('WARNING: No configurations found in configuration directory:' +CONFIG_DIR);\n  console.error('WARNING: To disable this warning set SUPPRESS_NO_CONFIG_WARNING in the environment.');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}